#!/usr/bin/python

from itertools import groupby
from operator import itemgetter
from subprocess import list2cmdline, Popen, PIPE
import os
import socket
import sys
import threading

try:
    from itertools import product
except ImportError:
    def product(*args, **kwds):
        # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy
        # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111
        pools = map(tuple, args) * kwds.get('repeat', 1)
        result = [[]]
        for pool in pools:
            result = [x+[y] for x in result for y in pool]
        for prod in result:
            yield tuple(prod)

try:
    from subprocess import CalledProcessError
except ImportError:
    # rips from python 2.7 subprocess.py
    class CalledProcessError(Exception):
        def __init__(self, returncode, cmd, output=None):
            self.returncode = returncode
            self.cmd = cmd
            self.output = output
        def __str__(self):
            return "Command '%s' returned non-zero exit status %d" % (self.cmd, self.returncode)

VerboseRun = False

def run(cmd, wait=True, ok_retcodes=(0,), **kwargs):
    if isinstance(cmd, unicode):
        cmd = cmd.encode('ascii')
    if isinstance(cmd, str):
        cmdstr = cmd
        cmd = shlex.split(cmd)
    else:
        cmdstr = list2cmdline(cmd)
    if VerboseRun:
        host = socket.gethostname()
        path = os.getcwd()
        print host + ':' + path, '+', list2cmdline(cmd)
    if kwargs.get('shell'):
        cmd = cmdstr
    p = Popen(cmd, **kwargs)
    p.cmdstr = cmdstr
    p.cmd = cmd
    if wait:
        retcode = p.wait()
        if retcode not in ok_retcodes:
            raise CalledProcessError(retcode, p.cmdstr)
    return p

# from collections import namedtuple
class repo(tuple): # namedtuple('repo', 'host path')
    def __new__(cls, host, path):
        if host in (socket.gethostname(), socket.getfqdn()):
            host = None
        return tuple.__new__(cls, (host, path))

    host = property(itemgetter(0))
    path = property(itemgetter(1))

    def runcmd(self, cmd, **kwargs):
        if self.islocal():
            proc = run(cmd, cwd=self.path, **kwargs)

        else:
            cmd = list2cmdline(cmd).replace("'", "\\'")
            cmd = list2cmdline(['cd', self.path]) + ' && ' + cmd
            cmd = "'" + cmd.replace("'", "\\'") + "'"
            cmd = ['ssh', self.host, '--', 'bash', '-c', cmd]
            proc = run(cmd, **kwargs)

        return proc

    @classmethod
    def parse(cls, s):
        try:
            host, path = s.split(':', 1)
        except ValueError:
            host = None
            path = s
        return cls(host, path)

    def islocal(self):
        return self.host is None

    def relativize_repos(self, repos):
        for r in repos:
            if r.host is None and self.host is not None:
                # TODO: option for fqdn instead
                yield socket.gethostname() + ':' + r.path
            elif r.host == self.host:
                yield r.path
            else:
                yield str(r)

    def add_repos(self, remote, *repos):
        cmd = ['git', 'clique']
        if VerboseRun: cmd.append('--verbose')
        cmd += ['add', '--change-only', remote]
        cmd.extend(self.relativize_repos(repos))
        self.runcmd(cmd)

    def remove_repos(self, remote, *repos):
        cmd = ['git', 'clique']
        if VerboseRun: cmd.append('--verbose')
        cmd += ['rm', '--change-only', remote]
        cmd.extend(self.relativize_repos(repos))
        self.runcmd(cmd)

    def remove_remote(self, remote):
        self.runcmd(('git', 'remote', 'rm', remote))

    def get_remote_urls(self, remote):
        try:
            urls = self.runcmd((
                'git', 'config',  '--get-all', 'remote.' + remote + '.url'
            ), stdout=PIPE)
        except CalledProcessError:
            return ()
        else:
            return (line.rstrip('\r\n') for line in urls.stdout)

    def __str__(self):
        if self.host is None:
            return self.path
        else:
            return self.host + ':' + self.path

class Command(object):
    def __init__(self, opts, args):
        self.opts = opts
        self.args = args

        if not len(args): parser.error('missing remote')
        self.remote = args.pop(0)

    @property
    def repo(self):
        try:
            return self._repo
        except AttributeError:
            pass

        p = Popen(('git', 'rev-parse', '--show-toplevel'), stdout=PIPE)
        if p.wait() != 0:
            raise RuntimeError(
                'git rev-parse --show-toplevel exited non-zero: %d' % p.returncode)
        path = p.stdout.readline().strip()
        path = os.path.realpath(path)
        if path.endswith('/.git'):
            path = path[:-5]
        self._repo = repo(None, path)
        return self._repo

class AddCommand(Command):
    def __init__(self, opts, args):
        super(AddCommand, self).__init__(opts, args)
        if not len(args): parser.error('missing urls')
        self.changed = set()
        self.repos = set(repo.parse(url)
            for url in self.repo.get_remote_urls(self.remote))

    def change(self, r):
        if r not in self.repos:
            if not self.repos:
                run(('git', 'remote', 'add', self.remote, str(r)))
            else:
                run(('git', 'remote', 'set-url', '--add', self.remote, str(r)))
            self.repos.add(r)
            return True

    def change_changee(self, r):
        if self.opts.notthis:
            r.add_repos(self.remote, *self.repos)
        else:
            r.add_repos(self.remote, self.repo, *self.repos)

    def propagate(self, r):
        r.add_repos(self.remote, *self.changed)

    def __call__(self):
        for url in self.args:
            r = repo.parse(url)
            if r == self.repo: continue
            if self.change(r):
                self.changed.add(r)

        if not self.changed or self.opts.changeonly: sys.exit(0)

        for r in self.changed:
            self.change_changee(r)

        for r in self.repos - self.changed:
            self.propagate(r)

class RmCommand(AddCommand):
    def change(self, r):
        if r in self.repos:
            if len(self.repos) == 1:
                run(('git', 'remote', 'rm', self.remote))
            else:
                run(('git', 'remote', 'set-url', '--delete', self.remote, str(r)))
            self.repos.remove(r)
            return True

    def change_changee(self, r):
        r.remove_remote(self.remote)

    def propagate(self, r):
        r.remove_repos(self.remote, *self.changed)

class TeardownCommand(Command):
    def __call__(self):
        for url in get_remote_urls(self.remote):
            r = repo.parse(url)
            r.remove_remote(self.remote)
        run(('git', 'remote', 'rm', self.remote))

class SyncCommand(Command):
    def __call__(self):
        stack = sorted(repo.parse(url)
            for url in self.repo.get_remote_urls(self.remote))
        relations = set((self.repo, r) for r in stack)
        visited = set()
        while stack:
            cur = stack.pop(0)
            visited.add(cur)
            for url in cur.get_remote_urls(self.remote):
                r = repo.parse(url)
                if r not in visited:
                    stack.append(r)
                relations.add((cur, r))
        missing = (rel
            for rel in product(set((self.repo,)) | visited, visited)
            if rel not in relations and rel[0] != rel[1])
        for a, rels in groupby(missing, itemgetter(0)):
            repos = tuple(b for _, b in rels)
            print 'Connecting', a, '->',
            print '{',  ', '.join(sorted(map(str, repos))), '}'
            a.add_repos(self.remote, *repos)

class RunCommand(Command):
    def __init__(self, opts, args):
        super(RunCommand, self).__init__(opts, args)
        if not len(args): parser.error('missing command')
        self.command = args
        self.repos = [] if self.opts.notthis else [self.repo]
        self.repos.extend(repo.parse(url)
            for url in self.repo.get_remote_urls(self.remote))

    def shunt_pipe(self, pfx, f):
        for line in f:
            line = line.rstrip('\r\n')
            print pfx, line
            sys.stdout.flush()
        f.close()

    def shunt_pipe_thread(self, pfx, f):
        t = threading.Thread(target=self.shunt_pipe, args=(pfx, f))
        t.start()
        return t

    def __call__(self):
        all_ok = True
        for i, r in enumerate(self.repos):
            if i > 0: print
            print r, '$', list2cmdline(self.command)
            p = r.runcmd(self.command, shell=True, wait=False,
                         stdout=PIPE, stderr=PIPE)
            ts = [
                self.shunt_pipe_thread('  out>', p.stdout),
                self.shunt_pipe_thread('  err>', p.stderr)]
            for t in ts:
                t.join()
            retcode = p.wait()
            if retcode != 0:
                print '  exited non-zero:', retcode
                all_ok = False
        return 0 if all_ok else 1

import optparse
parser = optparse.OptionParser(
    usage='%prog add|rm <remote> <url> [<url> [...]]\n'
    '       %prog teardown <remote>\n'
    '       %prog sync <remote>\n'
    '       %prog run <remote> <command>')
parser.add_option('-v', '--verbose',
    help='Print verbose output (command run)',
    dest='verbose', action='store_true', default=False)
parser.add_option('--change-only',
    help='Only make changes to the local repository;'
         ' don\'t propagate changes to other repositories.',
    dest='changeonly', action='store_true', default=False)
parser.add_option('--not-this',
    help='Don\'t include this repository when propagating to other '
         'repositories or when running commands; useful for repositories '
         'external to the clique.',
    dest='notthis', action='store_true', default=False)
opts, args = parser.parse_args()

if not len(args): parser.error('missing action')
action = args.pop(0)

commands = {
    'add': AddCommand,
    'rm': RmCommand,
    'teardown': TeardownCommand,
    'sync': SyncCommand,
    'run': RunCommand,
}

try:
    cmd = commands[action]
except KeyError:
    print >>sys.stderr, "Invaild action", repr(action)
    sys.exit(1)

if opts.verbose:
    VerboseRun = True

cmd = cmd(opts, args)
retcode = cmd()
sys.exit(0 if retcode is None else retcode)
