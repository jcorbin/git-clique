#!/usr/bin/python

# TODO: rip out all of the python 2.5 compatability and spin that off into a branch
# TODO: parallel run in add/rm/sync

from itertools import groupby, product
from operator import itemgetter
from subprocess import CalledProcessError, list2cmdline, PIPE
import errno
import os
import signal
import socket
import subprocess
import sys
import threading

VerboseRun = False

def shunt_pipe(pfx, f):
    for line in f:
        line = line.rstrip('\r\n')
        print pfx, line
        sys.stdout.flush()
    f.close()

def shunt_pipe_thread(pfx, f):
    t = threading.Thread(target=shunt_pipe, args=(pfx, f))
    t.start()
    return t

class Popen(subprocess.Popen):
    Dangling = {}
    Processes = {}

    @classmethod
    def handle_sigchld(cls, signum, frame):
        try:
            while True:
                pid, status = os.waitpid(-1, os.WNOHANG)
                if pid == 0: break
                try:
                    self = cls.Processes.pop(pid)
                except KeyError:
                    cls.Dangling[pid] = status
                    continue
                self._handle_exitstatus(status)
        except OSError as err:
            if err.errno != errno.ECHILD: raise

    def _execute_child(self, *args):
        super(Popen, self)._execute_child(*args)
        self.Processes[self.pid] = self
        try:
            status = self.Dangling.pop(self.pid)
        except KeyError:
            pass
        else:
            self._handle_exitstatus(status)

    def wait(self):
        while self.returncode is None:
            signal.pause()
        return self.returncode

signal.signal(signal.SIGCHLD, Popen.handle_sigchld)

def run(cmd, wait=True, ok_retcodes=(0,), **kwargs):
    verbose = kwargs.pop('verbose', VerboseRun)
    if isinstance(cmd, unicode):
        cmd = cmd.encode('ascii')
    if isinstance(cmd, str):
        cmdstr = cmd
        cmd = shlex.split(cmd)
    else:
        cmdstr = list2cmdline(cmd)
    if verbose:
        host = socket.gethostname()
        path = kwargs.get('cwd', os.getcwd())
        print host + ':' + path, '+', list2cmdline(cmd)
    if kwargs.get('shell'):
        cmd = cmdstr
    p = Popen(cmd, **kwargs)
    p.cmdstr = cmdstr
    p.cmd = cmd
    if wait: wait_check(p, ok_retcodes)
    return p

def wait_check(proc, ok_retcodes=(0,)):
    retcode = proc.wait()
    if retcode not in ok_retcodes:
        raise CalledProcessError(retcode, proc.cmdstr)
    return proc

def prun_repo_cmds(repo_cmd_kwargs):
    # TODO: thread pipe shunts?
    procs = [
        (repo, cmd, repo.runcmd(
            cmd, stdout=PIPE, stderr=PIPE,
            verbose=False, wait=False, **kwargs))
        for repo, cmd, kwargs in repo_cmd_kwargs]
    all_ok = True
    for i, (repo, cmd, p) in enumerate(procs):
        if i > 0: print
        print repo, '$', list2cmdline(cmd)
        ts = [
            shunt_pipe_thread('  out>', p.stdout),
            shunt_pipe_thread('  err>', p.stderr)]
        retcode = p.wait()
        for t in ts:
            t.join()
        if retcode != 0:
            print '  exited non-zero:', retcode
            all_ok = False
    return 0 if all_ok else 1

# from collections import namedtuple
class repo(tuple): # namedtuple('repo', 'host path')
    def __new__(cls, host, path):
        if host in (socket.gethostname(), socket.getfqdn()):
            host = None
        self = super(repo, cls).__new__(cls, (host, path))
        self._remote_repos_cache = {}
        return self

    host = property(itemgetter(0))
    path = property(itemgetter(1))

    def runcmd(self, cmd, **kwargs):
        if self.islocal():
            proc = run(cmd, cwd=self.path, **kwargs)

        else:
            kwargs['shell'] = False
            cmd = list2cmdline(cmd).replace("'", "\\'")
            cmd = list2cmdline(['cd', self.path]) + ' && ' + cmd
            cmd = "'" + cmd.replace("'", "\\'") + "'"
            cmd = ['ssh', self.host, '--', 'bash', '-c', cmd]
            proc = run(cmd, **kwargs)

        return proc

    @classmethod
    def parse(cls, s):
        try:
            host, path = s.split(':', 1)
        except ValueError:
            host = None
            path = s
        return cls(host, path)

    def islocal(self):
        return self.host is None

    def relativize_repos(self, repos):
        for r in repos:
            yield self.relativize_repo(r)

    def relativize_repo(self, r):
        if r.host is None and self.host is not None:
            # TODO: option for fqdn instead
            return socket.gethostname() + ':' + r.path
        elif r.host == self.host:
            return r.path
        else:
            return str(r)

    def add_repos(self, remote, *repos):
        current_repos = self.remote_repos(remote)

        # TODO: worth it to use a set?
        repos = tuple(r for r in repos
            if r not in current_repos and r != self)
        added = repos
        if added:
            if not current_repos:
                self.runcmd(('git', 'remote', 'add', remote,
                    self.relativize_repo(added[0])))
                repos = added[1:]

            if len(repos) == 1:
                self.runcmd((
                    'git', 'remote', 'set-url', remote, '--add',
                    self.relativize_repo(repos[0])
                ), stdin=PIPE)
            elif repos:
                p = self.runcmd((
                    'xargs', '-0', '-n1',
                    'git', 'remote', 'set-url', remote, '--add'
                ), stdin=PIPE, wait=False)
                p.stdin.write('\0'.join(self.relativize_repos(repos)))
                p.stdin.close()
                wait_check(p)

            self._remote_repos_cache[remote] = current_repos + added
        return added

    def remove_repos(self, remote, *repos):
        current_repos = self.remote_repos(remote)

        # TODO: worth it to use a set?
        repos = tuple(r for r in repos if r in current_repos)
        if repos:
            current_repos = tuple(r for r in current_repos if r not in repos)

            if not current_repos:
                self.runcmd(('git', 'remote', 'remove', remote))
            elif len(repos) == 1:
                self.runcmd((
                    'git', 'remote', 'set-url', remote, '--delete',
                    self.relativize_repo(repos[0])
                ), stdin=PIPE)
            else:
                p = self.runcmd((
                    'xargs', '-0', '-n1',
                    'git', 'remote', 'set-url', remote, '--delete'
                ), stdin=PIPE, wait=False)
                p.stdin.write('\0'.join(self.relativize_repos(repos)))
                p.stdin.close()
                wait_check(p)

            self._remote_repos_cache[remote] = current_repos
        return repos

    def remove_remote(self, remote):
        self.runcmd(('git', 'remote', 'rm', remote))

    def remote_repos(self, remote):
        try:
            return self._remote_repos_cache[remote]
        except KeyError:
            pass
        try:
            urls = self.runcmd((
                'git', 'config',  '--get-all', 'remote.' + remote + '.url'
            ), stdout=PIPE)
        except CalledProcessError:
            return ()
        else:
            self._remote_repos_cache[remote] = repos = tuple(
                self.parse(line.rstrip('\r\n'))
                for line in urls.stdout)
            return repos

    def __str__(self):
        if self.host is None:
            return self.path
        else:
            return self.host + ':' + self.path

class Command(object):
    def __init__(self, opts, args):
        self.opts = opts
        self.args = args

        if not len(args): parser.error('missing remote')
        self.remote = args.pop(0)

    @property
    def repo(self):
        try:
            return self._repo
        except AttributeError:
            pass

        p = Popen(('git', 'rev-parse', '--show-toplevel'), stdout=PIPE)
        if p.wait() != 0:
            raise RuntimeError(
                'git rev-parse --show-toplevel exited non-zero: %d' % p.returncode)
        path = p.stdout.readline().strip()
        path = os.path.realpath(path)
        if path.endswith('/.git'):
            path = path[:-5]
        self._repo = repo(None, path)
        return self._repo

class AddCommand(Command):
    def __init__(self, opts, args):
        super(AddCommand, self).__init__(opts, args)
        if not len(args): parser.error('missing urls')
        self.changed = set()
        self.repos = set(self.repo.remote_repos(self.remote))

    def change(self, repos):
        return self.repo.add_repos(self.remote, *repos)

    def change_changee(self, r):
        if self.opts.notthis:
            r.add_repos(self.remote, *self.repos)
        else:
            r.add_repos(self.remote, self.repo, *self.repos)

    def propagate(self, r):
        r.add_repos(self.remote, *self.changed)

    def __call__(self):
        repos = tuple(repo.parse(url) for url in self.args)
        self.changed.update(self.change(repos))

        for r in self.changed:
            self.change_changee(r)

        for r in self.repos - self.changed:
            self.propagate(r)

class RmCommand(AddCommand):
    def change(self, repos):
        return self.repo.remove_repos(self.remote, *repos)

    def change_changee(self, r):
        r.remove_remote(self.remote)

    def propagate(self, r):
        r.remove_repos(self.remote, *self.changed)

class TeardownCommand(Command):
    def __call__(self):
        for r in remote_repos(self.remote):
            r.remove_remote(self.remote)
        run(('git', 'remote', 'rm', self.remote))

class SyncCommand(Command):
    def __call__(self):
        stack = sorted(self.repo.remote_repos(self.remote))
        relations = set((self.repo, r) for r in stack)
        visited = set(stack)
        while stack:
            a = stack.pop(0)
            for b in a.remote_repos(self.remote):
                if b not in visited:
                    visited.add(b)
                    stack.append(b)
                relations.add((a, b))
        a = set((self.repo,)) | visited
        b = visited if self.opts.notthis else a
        missing = (rel for rel in product(a, b)
            if rel not in relations and rel[0] != rel[1])
        missing = sorted(missing, key=itemgetter(0))
        for a, rels in groupby(missing, itemgetter(0)):
            repos = sorted(b for _, b in rels)
            print 'Connecting %s -> {%s}' % (a, ', '.join(map(str, repos)))
            a.add_repos(self.remote, *repos)

class RunCommand(Command):
    def __init__(self, opts, args):
        super(RunCommand, self).__init__(opts, args)
        if not len(args): parser.error('missing command')
        self.command = args
        self.repos = [] if self.opts.notthis else [self.repo]
        self.repos.extend(self.repo.remote_repos(self.remote))

    def __call__(self):
        return prun_repo_cmds(
            (r, self.command, {'shell': True})
            for r in self.repos)

class PushCommand(Command):
    # TODO: support topologies other than star (binary tree would be nice)

    def __init__(self, opts, args):
        super(PushCommand, self).__init__(opts, args)
        self.argspec = args.pop(0) if args else None

    def __call__(self):
        if self.argspec:
            cmd = lambda u: ('git', 'push', u, self.argspec)
        else:
            cmd = lambda u: ('git', 'push', u)
        repos = self.repo.remote_repos(self.remote)
        prun_repo_cmds(
            (self.repo, cmd(url), {})
            for url in self.repo.relativize_repos(repos))

import optparse
parser = optparse.OptionParser(
    usage='%prog add|rm <remote> <url> [<url> [...]]\n'
    '       %prog teardown <remote>\n'
    '       %prog sync <remote>\n'
    '       %prog run <remote> <command>\n'
    '       %prog push <remote>')
parser.add_option('-v', '--verbose',
    help='Print verbose output (command run)',
    dest='verbose', action='store_true', default=False)
# TODO: rename this option... what to call a repository which is connected
#       to all clique members, but NOT vice-versa...
parser.add_option('--not-this',
    help='Don\'t include this repository when propagating to other '
         'repositories or when running commands; useful for repositories '
         'external to the clique.',
    dest='notthis', action='store_true', default=False)
opts, args = parser.parse_args()

if not len(args): parser.error('missing action')
action = args.pop(0)

commands = {
    'add': AddCommand,
    'rm': RmCommand,
    'teardown': TeardownCommand,
    'sync': SyncCommand,
    'run': RunCommand,
    'push': PushCommand,
}

try:
    cmd = commands[action]
except KeyError:
    print >>sys.stderr, "Invaild action", repr(action)
    sys.exit(1)

if opts.verbose:
    VerboseRun = True

cmd = cmd(opts, args)
retcode = cmd()
sys.exit(0 if retcode is None else retcode)
